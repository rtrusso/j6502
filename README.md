Contents
--------

1. Getting Started
2. Project Overview
3. Class Library
4. Debugger Instructions


1. Getting Started
------------------

## Requirements

Release 1.1 was built and tested with OpenJDK 11.0.4 and gradle 4.4.1.

## Building

The project is built using gradle. The main build output is `j6502.jar`.

    gradle jar

Please be aware the code currently compiles with some deprecation warnings.

### Generated source files

Note that some of the source files have to be generated:

| Source Generator's Source  | Source Generator Class | Generated Source    |
|----------------------------|------------------------|---------------------|
| J6502ConstantsCreator.java | J6502ConstantsCreator  | J6502Constants.java |
| J6502Creator.java          | J6502Creator           | J6502.java          |

Compile the Source Generator's Source file into the Source Generator
Class. The Source Generator Class is in the package
`j6502.build`. Execute the Source Generator Class as an application
(both have a `main` method) to generate the corresponding Generated
Source file. The Generated Source file is then compiled into the final
output jar.

## No Install

No installation is required. You can run the tools directly from
j6052.jar. You may find it useful to copy the build output, j6502.jar,
to your JRE extension directory:

    cp j6502.jar $JAVA_HOME/jre/lib/ext

## Running the tools

The debugger application can be executed like this:

    $ java -jar j6502.jar

With the jar in your classpath, you could
execute the debugger application's entry point like this:

    $ java j6502.debugger.Main

With the jar file in your classpath, you can get the classes into your
java programs like this:

    import j6502.*;

2. Project Overview
-------------------

J6502 is a java class library for emulating the MOS Design 6502 CPU.
This 8-bit cpu was used in numerous electronic devices, two of the
coolest being (in the author's opinion) the NES and Commodore 64.
J6502 currently supports all documented opcodes and addressing modes
of the 6502.  Unlike many 6502 emulator cores, it emulates BCD (binary
coded decimal) mode.  Many other 6502 emulator cores skip BCD mode
since they were intended for use in an NES emulator, and the NES used
a custom 6502 which didn't support BCD.

J6502 also includes a graphical, interactive (but simple) debugger.
It reads object code in a simple format, which happens to be the
default format used by Robert Norris' 6502 assembler, Orgasm (this is
GPL and is available from freshmeat.net).  The debugger allows you to
load object code in this format, look at it in disassembled form (one
256-byte page at a time), and step through it while watching the 6502
registers.

The source code for actual emulation (J6502.java) is actually
generated by another java program, which reads in the 6502
specification file (6502.txt).  This file gives the opcodes, clock
cycles, available addressing modes, and template java code for each
operation.  This file might be a semi-useful reference for 6502
assembly.  A note on its human-readable format is provided in a
comment at the top of the file.

The information used to write this emulator comes from a great book
named "6502 Assembly Language Programming".  Here is some important
information on it:

6502 Assembly Language Programming
Lance A. Leventhal
Copyright (C) 1979, 1986 by McGraw-Hill, Inc.
ISBN 0-07-881216-X


3. Class Library
----------------

Following is some general information on the j6502 class library.  For
more detailed information, please view the the Javadoc-generated
documentation with your favorite web browser.

    package j6502:

    class AddressingMode
    class DefaultMemoryModel (implements MemoryModel)
    class Disassembler
    class J6502Constants
    class J6502Skeleton
     \
      class J6502
    class J6502Registers
    interface MemoryModel

## AddressingMode

Enumerates the possible addressing modes of the 6502.

## MemoryModel & DefaultMemoryModel

This interface and default implementation (respectively), specify how
a J6502 will get data from memory.  Any time the emulated 6502 reads
or writes to memory, it must do so through a MemoryModel (one can be
specified to the J6502 constructor).

This slows down emulation, but it is necessary to do things like
emulate video ram.  In your implementation of MemoryModel, you could
set aside some memory for video ram ($0200 through $0300 or
something), and trap any writes to that memory, causing a pixel to be
drawn on your emulated screen.  The possibilites for MemoryModel
implementations are endless.

## Disassembler

Given a MemoryModel, a Disassembler will decode the instruction at a
specified address in that memory space, returning a String which
contains the disassembled instruction.

## J6502Constants

This interface contains some tables of 6502 information, such as
instruction size for opcode, clock cycles for opcode, mnemonic for
opcode, etc.

## J6502Skeleton & J6502

These are the core of the emulator which represent the 6502 CPU.
J6502Skeleton is an abstract class that provides all of the support
functions for 6502 emulation (how to add in BCD mode, how to push
things onto the 6502's 256-byte stack, etc.).  J6502, which is
automatically generated, extends this class and provides an
implementation for one key abstract method.  This one is a 256-element
switch (), which decodes the opcode and performs the required task.


4. Debugger Instructions
------------------------

The provided debugger is very simple, but it allows you to load object
code (generated by orgasm), and step through it, which is fun.  If you
are counting clock cycles when you write 6502 assembly, you may also
find it useful. This project includes a few example assembly files
(examples/*.asm) and the assembled object code (examples/*.o) which
you can try out using the debugger.

Run this command to get the debugger up:

    java -jar j6502.jar

You will be greeted by the main screen, which contains the current
memory page (these are 256-byte sections of memory which start at
address 0) in a table on the left and a bunch of controls and readouts
on the right.

To get a quick idea of how to use the debugger, load up the file
'examples/bubblesort.o'.  As its name implies, it is an (inefficient)
implementation of bubblesort in 6502 assembly.  Just load up that
file, and start stepping through it with the "step" button.

## Memory Display

The memory page display on the left shows, in three columns, the
address, the contents of memory at that address, and the instruction
at that address (respectively).  The instruction column may be blank,
depending on whether the contents at that address are part of an
instruction earlier in memory, or do not represent a documented
opcode.

You can control which memory page you are displaying by right-clicking
this display, and then using one of these options: 'next page',
'previous page', or 'page ...'.  The 'page ...' option will bring up a
small window which will allow you to jump to any one of the 256 pages
(the 6502, as you may know, can only address 64k of ram without some
kind of aid, like the MMCs in NES cartridges).

From the popup menu you got by right-clicking, you can also choose to
'disassemble' or 'dissassemble at pc'.  The 'disassemble' option
starts disassembling at the top of the page.  The 'disassemble at pc'
option starts disassembling at the row that is selected (note that
this is also the location of the program counter).  This might be
useful if you know that your code starts at some non-page-aligned
address, and there is some data between the start of the page and your
code which is screwing up the disassembly.

## Controls

The section on the right includes some buttons and displays.  Here you
can cause the cpu to step one instruction (press the "step" button),
go back one instruction (press the "undo" button - only 64 of these
are memorized, but that number can be changed easily in Main.java -
see UNDO_LIMIT), and see the status of the processor.

The "clocks" text field shows how many clock cycles were elapsed by
the 6502 in executing the last instruction.

The "elapsed clocks" field shows how many clocks elapsed since the
last reset.  These occur when you choose the "reset" option from the
main menu, and when you load an object code file.

The section displaying all of the registers can be right-clicked to
choose hexadecimal or binary output.

Below the registers is a small, 3-column table.  If executing an
instruction causes some memory locations to be written to, this table
will show those locations along with the values contained in them,
before and after the write.  The order of the rows, from top to
bottom, is the order in which they were written.


## Main menu

You can choose one of three options: "open ...", "reset", and "quit".

### open ...

A window will open and allow you to choose a file, starting in the
working directory.  This file is optimally an object code file
generated by orgasm (a.out or linux_kernel_for_6502.o, etc.), but can
be any old file.  As long as it is at least 3 bytes long, and can fit
at address specified by the first two bytes (little endian order), it
will be happily loaded and disassembled by the debugger.

### reset

This will set the CPU to its initial state, and set the contents of
all memory locations to 0.

### quit

Does just what it says.

